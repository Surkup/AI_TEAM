# Архитектура контекста и памяти AI_TEAM

**Статус**: Концептуальный документ (Draft)
**Версия**: 1.2
**Дата**: 2025-12-19
**Автор**: ChatGPT (экспертная ревизия)
**Источник**: Внешняя экспертиза архитектуры

---

## 1. Введение

Данный документ фиксирует архитектурную концепцию управления памятью и контекстом
в мультиагентной системе AI_TEAM. Он предназначен для концептуального осмысления
и протоколирования идей, без преждевременного ухода в реализацию.

### Ключевой принцип

> **STATE OUTSIDE THE MODEL**
>
> LLM не является хранилищем памяти. Она — вычислительный процессор.
> Память системы всегда находится вне модели и управляется архитектурно.

---

## 2. Пространства памяти (Memory Namespaces)

Для предотвращения контекстного смешивания вводится строгая сегментация памяти.

### 2.1. Project Memory (Project Namespace)

- Отдельное пространство памяти на каждый проект
- Полностью изолировано от других проектов
- Содержит:
  - Canon проекта (утверждённые факты, правила, решения)
  - Историю принятых решений
  - Ключевые артефакты и ссылки на них

**Пример:**
- Проект A — книга в жанре хоррор
- Проект B — любовный роман
- Их память никогда не пересекается

### 2.2. Agent Personal Memory

- Личное пространство памяти конкретного агента
- Содержит:
  - рабочие эвристики
  - стилистические предпочтения
  - шаблоны мышления
- Не содержит проектных данных
- Может использоваться между проектами

### 2.3. Global Commons

- Общее пространство знаний без проектного контекста
- Содержит:
  - паттерны
  - системные промпты
  - лучшие практики
- Аналог: стандартная библиотека / tooling

---

## 3. Canon (SSOT проекта)

Canon — это единственный источник истины проекта.

### 3.1. Свойства Canon

- Строгий
- Версионируемый
- Изменяем только через формализованную процедуру

### 3.2. Semantic Versioning Canon

| Тип | Описание |
|-----|----------|
| **MAJOR** | Фундаментальные изменения (сюжетный поворот, смена архитектуры) |
| **MINOR** | Расширения (новая глава, новый модуль) |
| **PATCH** | Исправления формулировок |

### 3.3. Изменения Canon

Любое изменение оформляется как **Proposal**.

**Структура Proposal:**
- Proposal ID
- Target (что меняем)
- Action (добавить/изменить/удалить)
- Old Value
- New Value
- Rationale (обоснование)
- Evidence Reference (ссылка на доказательства)

**Решение по Proposal:**
- Auto (если нет конфликтов)
- Human-in-the-loop (если есть противоречия)

---

## 4. Context Pack (Оперативный контекст)

Контекст подаётся агенту не целиком, а в виде собранного пакета.

### 4.1. Принцип пирамиды релевантности

```
┌─────────────────────────────────┐
│         Hard Context            │  ← Обязательно
│   задача + роль + критич. Canon │
├─────────────────────────────────┤
│         Soft Context            │  ← Важно
│     последние 3–5 шагов         │
├─────────────────────────────────┤
│         RAG Context             │  ← По запросу
│   семантически релевантные      │
│   фрагменты из глубокой памяти  │
└─────────────────────────────────┘
```

### 4.2. Event-driven сборка

Контекст пересобирается:
- при смене фазы
- при обнаружении ошибки
- при запросе агента

**Не на каждом шаге** — это экономит ресурсы.

### 4.3. Минимальный состав Context Pack

| Компонент | Описание |
|-----------|----------|
| **Canon Slice** | Выжимка из SSOT / Канона проекта |
| **Task Intent** | Цель шага, критерии успеха, ограничения |
| **Relevant History** | Важные решения и краткая история |
| **Active Artifacts** | Ссылки/идентификаторы на нужные материалы |
| **Constraints** | Token budget, timeouts, policy restrictions, safety |
| **Open Questions** | Список нерешённых вопросов на текущем шаге |

---

## 5. Memory Curator (Инспектор памяти)

Memory Curator — системная роль.

### Функции:

- контроль роста памяти
- дедупликация
- архивирование
- сжатие (summarization)

### Ключевой принцип:

> **SUMMARY ≠ DELETE**
>
> Все summaries обязаны содержать ссылки на Raw Data.
> Любая оптимизация должна быть обратимой.

---

## 6. Управление ресурсами памяти

### 6.1. Ограничения

Память всегда конечна:
- по объёму
- по стоимости
- по времени доступа

### 6.2. Механизмы

- TTL для неключевых данных
- Архивация старых фаз проекта
- Сжатие истории с сохранением ссылок

### 6.3. Контроль

Memory Curator отслеживает:
- заполненность
- аномалии роста
- дубли

---

## 7. Защита от деградации и хаоса

### Риски:

- галлюцинации
- логические противоречия
- засорение памяти

### Контрмеры:

- Canon как SSOT
- Context Pack вместо «всего сразу»
- Curator вместо ручной чистки

---

## 8. Cross-Project Learning (Future Work)

### Допустимо:

- перенос навыков
- перенос паттернов
- перенос подходов

### Запрещено:

- перенос проектных данных
- перенос канона между проектами

---

## 9. Три слоя памяти в AI_TEAM

| Слой | Что хранит | Кто пишет | Кто читает |
|------|------------|-----------|------------|
| **Project Canon** | Правила, факты, решения | Через propose→review→accept | Все |
| **Agent Memory** | Эвристики, шаблоны, стиль | Сам агент | Сам агент |
| **Task Working Set** | Context Pack + промежуточные результаты | Оркестратор + агент | Агент |

---

## 10. Память Оркестратора

Важно: «память оркестратора» — это не память LLM, а его системное состояние.

### Компоненты:

| Компонент | Описание |
|-----------|----------|
| **Process State** | Текущий шаг, результаты, retries, таймауты |
| **Routing & Scheduling** | Доступные агенты, нагрузка, очереди |
| **Context Assembly Rules** | Правила сборки Context Pack |
| **Canon Update Workflow** | Очередь Proposals, кто утверждает |
| **Observability & Audit** | Корреляция задач, журналы событий |

---

## 11. Паттерн поведения агента с памятью

### 11.1. Перед выполнением шага

- Агент получает Context Pack
- Чётко видит: Canon vs Drafts vs History
- Извлекает только то, что нужно
- Принимает ограничения (инструменты/таймаут/политики)

### 11.2. Во время работы

- Ведёт «рабочий лог» (что сделал, почему)
- Сохраняет промежуточные артефакты как ссылки (не вставляет всё в текст)
- Регулярно резюмирует прогресс

### 11.3. По завершении

- Возвращает RESULT (output) и метрики
- (Опционально) возвращает:
  - `draft_update` — черновые дополнения
  - `propose_canon_update` — предложения изменить канон
  - `memory_hint` — что полезно сохранить в личную память
- **Ничего не «впечатывает» в канон напрямую**

---

## 12. Процесс обновления Canon

### 12.1. Propose (предложение)

Агент формирует структурированное предложение:
- что меняем
- почему
- какие доказательства/артефакты
- какой риск
- какая версия канона была входной

### 12.2. Review (проверка)

Проверка может быть:
- человеком (высокая критичность)
- CriticAgent (проверка логики/согласованности)
- валидатором схем/правил (формальная проверка)
- комбинацией

### 12.3. Accept (принятие)

Только после принятия:
- канон обновляется
- повышается версия
- изменения попадают в историю

### 12.4. Rollback

Если обнаружена ошибка:
- откатываем к предыдущей версии
- фиксируем причину

---

## 13. Сборка Context Pack: правила и стратегия

### 13.1. Базовый алгоритм

1. Определить цель шага (Intent) и требуемые capabilities
2. Взять Canon Slice — правила, которые влияют на текущий шаг
3. Подобрать Relevant History:
   - последние решения по теме
   - краткая timeline
   - «почему мы так решили»
4. Подтянуть Artifacts — ссылки на главы/документы/код/сцены
5. Соблюсти budgets:
   - лимит токенов
   - лимит времени
   - лимит на количество артефактов
6. Валидация:
   - структура пакета корректна
   - нет конфликтов версий
   - есть обязательные поля
7. Передать агенту

### 13.2. Стратегии подбора History

- Семантический поиск (embeddings) по задаче
- «Последние N решений» по теме
- Метки/теги решений (decision tags)
- Граф зависимостей (что связано с чем)
- «Сводка проекта» (всегда короткая) — как аварийный минимум

### 13.3. Token Budget дисциплина

- Canon Slice — всегда короткий
- History — резюмируется
- Артефакты — по ссылкам, не «вставкой»
- Агентам запрещено требовать «дай всё полностью», если это ломает бюджет

---

## 14. Практические примеры

### 14.1. Книга (25 глав)

**Canon:** сеттинг, персонажи, стиль, правила мира
**History:** принятые повороты сюжета, изменения персонажей с датами
**Artifacts:** главы, планы, заметки, сцены

**Context Pack для «Глава 5»:**
- кратко: кто герои, что было в 1–4, правила мира, что нельзя нарушать
- ссылки на документы глав 1–4

### 14.2. Разработка ПО

**Canon:** архитектурные решения, SSOT схемы, API контракты
**History:** ADR (арх. decision records), причины изменений
**Artifacts:** репозиторий, диаграммы, тесты, баг-репорты

**Context Pack для «Добавить retry policy»:**
- требования SSOT, текущие схемы сообщений, ссылка на код SDK
- список прошлых решений о рестартах и таймаутах

### 14.3. Генерация видеоконтента

**Canon:** бренд-гайд, ограничения, формат финального видео
**History:** что пробовали, что зашло, что не зашло, причины
**Artifacts:** сценарий, раскадровка, ассеты, звук

**Context Pack для «Сцена 7 монтаж»:**
- стиль, темп, правила переходов, ссылки на ассеты сцены 7
- краткая сводка сюжета вокруг сцены

---

## 15. Риски и слабые места

| Риск | Митигация |
|------|-----------|
| Засорение канона | propose→review→accept, роли, валидация |
| Конфликты версий | фиксировать canon_version в задачах, conflict-detector |
| «Плохой» retrieval | комбинировать стратегии, иметь fallback, логировать |
| Цена и латентность | кэш, инкрементальные сводки, лимиты |
| Безопасность и утечки | политика хранения, фильтры, запрет секретов в LLM memory |

---

## 16. Итоговое резюме

Данная архитектура:
- масштабируется
- экономит токены
- защищает от забывчивости LLM
- переводит интеллект из промптов в систему

Документ является концептуальной основой
для дальнейшей спецификации Memory / Knowledge Node.

---

## Связанные документы

- [STORAGE_SPEC_v1.0.md](../../SSOT/STORAGE_SPEC_v1.0.md) — спецификация хранилища
- [STORAGE_MEMORY_REVIEW_v1.0.md](./STORAGE_MEMORY_REVIEW_v1.0.md) — ревизия Storage
- [ORCHESTRATOR_SPEC_v1.0.md](../../SSOT/ORCHESTRATOR_SPEC_v1.0.md) — спецификация оркестратора
- [IMPLEMENTATION_ROADMAP.md](../../project/IMPLEMENTATION_ROADMAP.md) — план реализации

---

*Документ интегрирован: 2025-12-19*
*Источник: экспертная ревизия от ChatGPT (v1.1 + v1.2)*
