# Интерпретатор Process Card — Движок Оркестратора (v0.2)

**Дата**: 2025-12-17
**Автор**: Коллеги (обсуждение)
**Статус**: ЧЕРНОВИК

---

> **ВНИМАНИЕ: ЧЕРНОВИК**
>
> Этот документ является черновиком и требует:
> 1. Детальной проработки каждого пункта
> 2. Проверки на соответствие SSOT документации проекта
> 3. Утверждения перед интеграцией в основную документацию
>
> **НЕ ЯВЛЯЕТСЯ** частью SSOT. Идеи могут противоречить текущей архитектуре.
>
> **Требуется сверка с**:
> - [PROCESS_CARD_SPEC_v1.0.md](../../SSOT/PROCESS_CARD_SPEC_v1.0.md)
> - [MESSAGE_FORMAT_v1.1.md](../../SSOT/MESSAGE_FORMAT_v1.1.md)
> - [ORCHESTRATOR_SPEC_v1.0.md](../../SSOT/ORCHESTRATOR_SPEC_v1.0.md)
> - [mindbus_protocol_v1.md](../../SSOT/mindbus_protocol_v1.md)

---

# 1) Концептуальная идея: «Оркестратор = процессор + система команд»

## 1.1. Базовая метафора

| Компонент | Аналогия |
|-----------|----------|
| **Карточка процесса (Process Card)** | "программа": декларативное описание шагов, условий, переменных, повторов |
| **Оркестратор** | "процессор": читает "инструкции", валидирует, выполняет, ведёт состояние, логирует |
| **Инструменты/агенты** | "устройства/исполнители инструкций": кодер, ревьюер, ресёрчер и т.д. |

**Ключевой принцип из SSOT**: карточка "глупая", оркестратор "умный" (карточка не содержит произвольного кода, оркестратор обеспечивает безопасность).

## 1.2. Почему "берём готовый YAML-интерпретатор" — это правильно

Внутри "движка" два слоя:

1. **Интерпретация формата YAML/JSON** (текст → структура данных)
   - Это давно решено: стандартные парсеры

2. **Интерпретация смысла карточки** (Process Card DSL)
   - Это ваш "набор инструкций процессора": steps, condition, action, output, repeat/retry, ограничения

**Итого**: готовый YAML-парсер + ваша бизнес-DSL-семантика = быстрый и надёжный путь к MVP.

## 1.3. "Оркестратор строгий процессор, а качество/проверки — инструменты"

- Оркестратор умеет: валидировать карточку, выполнять шаги, делать ветвления/циклы, обеспечивать лимиты
- Качество результата (критика/скоринг/ревью) — это отдельные action-шаги, выполняемые агентами

---

# 2) Подробное техзадание: как реализовать движок

## 2.1. Входной язык карточек: YAML/JSON как контейнер

SSOT фиксирует: Process Card записывается в YAML или JSON, предпочтительно YAML.

**Решение**:
- Берём готовую библиотеку YAML/JSON-парсинга
- На выходе получаем обычную структуру данных (dict/object)
- Дальше — валидатор и интерпретатор Process Card

## 2.2. Валидация: "не исполнять, если невалидно"

**Требования спецификации**:
- "Валидация карточки перед исполнением"
- "Некорректная карточка НЕ исполняется"
- Проверки на бесконечные циклы/лимиты

**Решение (MVP и дальше)**:

1. **JSON Schema** для Process Card (структура: metadata/spec/steps/variables)
2. **Валидация** типов/обязательных полей/enum-значений
3. **Статические проверки** "безопасности исполнения":
   - Лимит шагов
   - Лимит повторов
   - Запрет бесконечных повторов
   - Лимит размера переменных (пример: 10MB, конфигурируемо)

## 2.3. Компиляция в внутреннее представление (IR/AST)

Оркестратору полезно иметь внутренний формат:
- **Граф шагов** (узлы = шаги, рёбра = переходы)
- **Таблица переменных** процесса
- **Таблица ограничений/лимитов**
- **Ссылки на then/else** для condition

**Почему важно**:
- Проще ловить ошибки ссылок (`then: "step_x"` на несуществующий шаг)
- Проще детектить циклы
- Проще делать дебаг/логирование/визуализацию
- Проще добавлять новые типы шагов

## 2.4. Семантика исполнения шагов (instruction set)

### 2.4.1. action-шаг (вызов агента/инструмента)

```yaml
- id: "generate_code"
  action: "code_generation"
  params: {...}
  output: code_result
```

**Семантика**: оркестратор находит узел с capability под action, отправляет команду через MindBus, ждёт результат, сохраняет в output.

**Решение на уровне движка**:
1. Резолв params (подстановка `${...}` из переменных)
2. Формирование COMMAND по SSOT формату: action, params, context, timeout_seconds, retry_policy, idempotency_key
3. Отправка в MindBus и ожидание RESULT/ERROR по reply-to/correlation
4. Запись результата в переменную output

### 2.4.2. condition-шаг (ветвление)

```yaml
- id: "check_quality"
  condition: "${review_result.score} >= 8"
  then: "step_publish"
  else: "step_improve"
```

**Решение**:
- Нужен безопасный интерпретатор выражений (не "произвольный Python/JS")
- Выражения читают только "контролируемое состояние" (переменные процесса)
- В движке: вычислить условие → выбрать следующий шаг

## 2.5. Переменные и контекст: контролируемое состояние процесса

SSOT фиксирует: переменные видны только внутри процесса, без доступа к глобальному состоянию, без побочных эффектов.

**Решение**:
```python
state = {
    "variables": {...},
    "step_outputs": {...},
    "metadata": {...},
    "runtime": {...}
}
```

- Подстановка `${var}` только из state
- Внешние изменения мира — только через action к агентам

## 2.6. Надёжность: ретраи и идемпотентность

SSOT определяет:
- Orchestrator ретраит на уровне COMMAND
- Агент "не ретраит" (один раз выполняет, иначе ERROR)
- Идемпотентность через `idempotency_key`

**Решение**:
- Генерировать idempotency_key детерминированно (process_id + step_id + attempt)
- Применять retry_policy (max_attempts/backoff)
- Различать retryable vs non-retryable ошибки

## 2.7. Поиск исполнителя: Registry + Node Passport

**Решение**:
1. Шаг action → запрос в Registry: "дай ноды Ready/Running с нужной capability"
2. Выбор стратегии (round-robin, least-busy, affinity)
3. Отправка COMMAND выбранному агенту через MindBus routing keys

## 2.8. Логи, контрольные точки, улучшение карточек

**Реализация в DSL**:
- Контрольные точки = отдельные шаги `action: review/approve/critique` + `condition` + ветвление
- Цикл улучшений = петля "сгенерировать → проверить → доработать → проверить…"
- "Улучшить карточку" = отдельный action (например `refine_process_card`) с output в новую версию

---

# 3) Возможные сложности и пути решения

## 3.1. YAML как формат: безопасность

**Риск**: YAML богатый (якоря, сложные типы)
**Решение**: разрешить "безопасное подмножество" YAML, использовать safe-load режим

## 3.2. Выражения в condition: не скатиться в "произвольный код"

SSOT запрещает произвольный код и пользовательские функции.
**Решение**: отдельный маленький expression-engine (ограниченный синтаксис, только чтение state)

## 3.3. Статический анализ графа шагов

**Риски**:
- then/else ссылается на несуществующий шаг
- Цикл без лимитов
- "Слишком большая" карточка

**Решение**: компиляция в граф + анализ до запуска (fail-fast)

## 3.4. Границы ответственности: "умный оркестратор" vs "не монолит"

**Баланс**:
- В оркестраторе только универсальные механики: парсинг/валидация/планирование/переходы/лимиты/ретраи/логирование/транспорт
- Все "умные" вещи — только как action-инструменты

## 3.5. Интеграция с MindBus: согласованность контрактов

**Риск**: "движок" начнёт шить детали транспорта в карточку
**Решение**: строго соблюдать принцип "карточка не знает про RabbitMQ/CloudEvents"

## 3.6. Версионирование карточек и совместимость

SSOT требует version (semver).
**Решение**: политика "schema-per-version" или мигратор (v1 → v2)

## 3.7. Тестирование "процессора"

**Виды тестов**:
- **Unit**: парсер/валидатор/анализ графа/выражения
- **Integration**: mock-агенты (RESULT/ERROR, таймауты, retryable ошибки)
- **E2E**: реальный MindBus + минимальный Registry + 1–2 агента

---

## Следующие шаги

1. Собрать минимальную **"instruction set" таблицу** для движка (типы шагов v1: action/condition + repeat/retry + complete/fail)
2. Дать эталонный **"скелет" runtime-state** (какие поля держим в памяти процесса)

---

## Связанные документы

- [PROCESS_CARD_SPEC_v1.0.md](../../SSOT/PROCESS_CARD_SPEC_v1.0.md)
- [MESSAGE_FORMAT_v1.1.md](../../SSOT/MESSAGE_FORMAT_v1.1.md)
- [ORCHESTRATOR_SPEC_v1.0.md](../../SSOT/ORCHESTRATOR_SPEC_v1.0.md)
- [mindbus_protocol_v1.md](../../SSOT/mindbus_protocol_v1.md)
