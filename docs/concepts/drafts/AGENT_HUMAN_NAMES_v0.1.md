# Человеческие имена агентов — Display Identity (v0.1)

**Дата**: 2025-12-17
**Автор**: Коллеги (обсуждение)
**Статус**: ЧЕРНОВИК

---

> **ВНИМАНИЕ: ЧЕРНОВИК**
>
> Этот документ является черновиком и требует:
> 1. Детальной проработки каждого пункта
> 2. Проверки на соответствие SSOT документации проекта
> 3. Утверждения перед интеграцией в основную документацию
>
> **НЕ ЯВЛЯЕТСЯ** частью SSOT. Идеи могут противоречить текущей архитектуре.
>
> **Требуется сверка с**:
> - [NODE_PASSPORT_SPEC_v1.0.md](../../SSOT/NODE_PASSPORT_SPEC_v1.0.md)
> - [NODE_REGISTRY_SPEC_v1.0.md](../../SSOT/NODE_REGISTRY_SPEC_v1.0.md)
> - [ORCHESTRATOR_SPEC_v1.0.md](../../SSOT/ORCHESTRATOR_SPEC_v1.0.md)

---

# 1) Концептуальная идея

## 1.1. Два слоя идентификации

| Слой | Назначение | Примеры |
|------|-----------|---------|
| **Внутри системы** | Компоненты идентифицируют друг друга по системным идентификаторам | UID, node_id, selectors |
| **Для человека** | Отображается человеческое имя (ник/alias/display name) | "Елена", "Игорь", "Writer-1" |

**Ключевой принцип**: "человеческое имя" — это UI-функция монитора, а не обязательный системный контракт.

## 1.2. Хорошая новость: в Node Passport уже есть "человеческое имя"

В Kubernetes-логике паспорта уже присутствует:
- `metadata.uid` — уникальный системный идентификатор
- `metadata.name` — human-readable-name (человеко-читаемое имя)

То есть базовая "пара" уже предусмотрена стандартом паспорта.

## 1.3. Принцип адресации

- **Адресация/маршрутизация** — по UID и/или по селекторам (labels/capabilities/role)
- **Имя** — для интерфейса, логов, дебага, "переклички", диалогов

---

# 2) Задачи, которые надо решить

## 2.1. "Перекличка" и представление на совещании

**Сценарий**:
1. "Оркестратор, объяви перекличку"
2. "Кто в системе — представьтесь"
3. Человек видит не `uid=550e...`, а "Елена", "Игорь", "Writer-1"

## 2.2. Обращение к агенту по имени

**Сценарий**:
- "Оркестратор, спроси у Елены мнение"
- Если у человека нет "Елены", а есть только `agent.writer.001`, UX ломается

## 2.3. Не ломать SSOT

**Главный риск** — если сделать "human name" обязательным системным идентификатором:
- Коллизии имён (две "Елены")
- Необходимость глобального реестра имён
- Сложные правила уникальности/переименований
- "Имя" начнёт участвовать в адресации и станет источником ошибок

---

# 3) Варианты решения

## Вариант A (рекомендуемый для старта)

### Использовать `metadata.name` + таблицу отображения в Мониторе

**Идея**:
- В системе остаётся UID как "истина"
- В паспорте остаётся `metadata.name` как "человеко-читаемый идентификатор"
- Монитор хранит "справочник отображения": `node_uid -> display_name`

**Как работает**:
1. Агент при "перекличке" отвечает: uid, name, role, capabilities, краткое описание
2. Монитор выводит человеку "Елена", "Игорь", а в скобках может показывать name/uid
3. Когда человек говорит "спроси Елену" — это команда монитору:
   - Монитор находит `display_name="Елена"` → получает uid
   - Оркестратор адресует узел по UID/selector как обычно

**Плюсы**:
- ✅ Вообще не трогает SSOT протоколы
- ✅ Не добавляет обязательных полей
- ✅ Не заставляет оркестратор "понимать человеческие имена"
- ✅ Минимальный риск

**Минусы**:
- Справочник нужно где-то хранить (конфиг/БД монитора)
- Нужно правило: что показывать, если "Елена" не задана (fallback на `metadata.name`)

---

## Вариант B: Опциональный display name в Passport

Если хочется, чтобы "человеческое имя" приезжало вместе с паспортом:

**Рекомендуемый паттерн (в стиле Kubernetes)**:
- `metadata.labels["displayName"]` (если допускаются label-строки)
- **ИЛИ** `metadata.annotations["displayName"]` (чаще логичнее, потому что это не для селекторов)

**Правила**:
- `metadata.uid` — уникально всегда
- `metadata.name` — человеко-читаемо, желательно уникально в рамках окружения
- `displayName` — не уникально, может повторяться, для UI

**Почему не ломает архитектуру**:
- Оркестратор продолжает работать по UID/селектору
- Реестр хранит паспорт как есть
- Монитор просто лучше рисует UI

---

## Вариант C: "Обращение по имени" как Node Selector

Если "Елена" — это группа или роль, а не конкретный агент:

- Человеческое имя в UI маппится на selector:
  ```
  labels.role=writer AND labels.seniority=lead AND labels.persona=elena
  ```
- "Спроси Елену" = "спроси агента(ов) по селектору"

Полезно, если "Елена" — не конкретный процесс, а персона/роль.

---

# 4) Практические детали: как сделать "перекличку"

## 4.1. Как оркестратору узнать "кто в системе"

- Оркестратор делает запрос в Node Registry
- Получает список паспортов узлов со `status.phase=Running` (и/или Ready condition)
- Либо просто показывает список, либо запускает "introduce" команду

## 4.2. Как агенты "представляются"

Стандартный "intro payload":
```json
{
  "uid": "...",
  "name": "agent.writer.001",
  "role": "writer",
  "capabilities": ["generate_text", "edit_text"],
  "tools": ["openai_gpt4"],
  "version": "1.0.0",
  "status": "Ready",
  "about": "Я пишу статьи и редактирую тексты"
}
```

**Монитор отображает**:
- DisplayName (если есть) → иначе `metadata.name` → иначе короткий UID

## 4.3. Как адресовать "Елену" без изменения протоколов

1. Человек пишет в монитор: "спроси Елену"
2. Монитор резолвит в UID/selector
3. Оркестратор отправляет обычный COMMAND (ничего нового в MindBus/Message Format)

---

# 5) Открытые вопросы и задачи на будущее

## 5.1. Коллизии displayName ("две Елены")

**Решение**: монитор при конфликте спрашивает уточнение или показывает список:
- "Елена (writer)"
- "Елена (critic)"

## 5.2. Перезапуск узла и смена UID

Если UID "на инстанс", а нужна стабильная "личность":
- Использовать `metadata.name` как стабильный идентификатор
- Или ввести понятие `persona_id` (опционально, позже)

**На MVP**: монитор ведёт маппинг на `metadata.name` и обновляет uid при регистрации.

## 5.3. Где хранить таблицу имён

- **MVP**: конфиг монитора (YAML/JSON)
- **Далее**: отдельная маленькая БД/kv-store в мониторе
- **Важно**: не тащить это в общий Registry как обязательную часть

## 5.4. Безопасность/спуфинг (агент сам себе назначил "CEO")

Если displayName приходит от агента, он "самозаявленный".

**Решение**: монитор может:
- Доверять только своей таблице
- Или вводить "политику доверия" (allowlist/подпись паспорта) позже

## 5.5. Нужно ли оркестратору знать displayName?

**В концепции "оркестратор = процессор"** — нет.

Знать должен монитор (интерфейсный слой), максимум — отдельный "Directory/Identity" инструмент, но не ядро оркестратора.

---

# 6) Рекомендуемый следующий шаг

Оформить это как **SSOT-добавление "Display Identity (Monitor Layer)"**:
- Короткий стандарт для монитора
- Как он резолвит имена
- Какие fallbacks
- Как рисует перекличку
- Как обрабатывает коллизии

**Без правок в MindBus/Message Format/Registry.**

---

## Связанные документы

- [NODE_PASSPORT_SPEC_v1.0.md](../../SSOT/NODE_PASSPORT_SPEC_v1.0.md)
- [NODE_REGISTRY_SPEC_v1.0.md](../../SSOT/NODE_REGISTRY_SPEC_v1.0.md)
- [ORCHESTRATOR_SPEC_v1.0.md](../../SSOT/ORCHESTRATOR_SPEC_v1.0.md)
