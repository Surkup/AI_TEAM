# Концепция Оркестратора v0.2 — Полный черновик

**Дата**: 2025-12-17
**Автор**: Коллеги (обсуждение с интеграцией рецензии MESSAGE_FORMAT)
**Статус**: ЧЕРНОВИК

---

> **ВНИМАНИЕ: ЧЕРНОВИК**
>
> Этот документ является черновиком и требует:
> 1. Детальной проработки каждого пункта
> 2. Проверки на соответствие SSOT документации проекта
> 3. Утверждения перед интеграцией в основную документацию
>
> **НЕ ЯВЛЯЕТСЯ** частью SSOT. Идеи могут противоречить текущей архитектуре.
>
> **Требуется сверка с**:
> - [ORCHESTRATOR_SPEC_v1.0.md](../../SSOT/ORCHESTRATOR_SPEC_v1.0.md)
> - [MESSAGE_FORMAT_v1.1.md](../../SSOT/MESSAGE_FORMAT_v1.1.md)
> - [PROCESS_CARD_SPEC_v1.0.md](../../SSOT/PROCESS_CARD_SPEC_v1.0.md)
> - [NODE_PASSPORT_SPEC_v1.0.md](../../SSOT/NODE_PASSPORT_SPEC_v1.0.md)
> - [NODE_REGISTRY_SPEC_v1.0.md](../../SSOT/NODE_REGISTRY_SPEC_v1.0.md)

---

# Часть 1. Концептуальная идея

## 1) «Процессор и ISA»: гармония архитектуры, языка и исполнения

Ключевая метафора: оркестратор должен быть как процессор, а «язык» карточек процессов и сообщений — как система команд (ISA).

| Компонент | Аналогия | Назначение |
|-----------|----------|------------|
| **Process Card** | «программа» | Описание логики, ветвлений, циклов, контрольных точек, критериев качества |
| **Message Format** | «кодировка инструкций» | Как выглядит команда/результат/ошибка/событие/управление |
| **MindBus/CloudEvents/AMQP** | «шина и протокол передачи» | Как доставляем инструкции и результаты |
| **Node Passport + Node Registry** | «таблица возможностей/ресурсов» | На какие "исполнители" можно назначать инструкции |
| **Оркестратор** | «ядро исполнения + планировщик» | Назначает работу, следит за зависимостями, делает ретраи |

**Критически важно**: это не «всё в одном», а строго разделённые SSOT-слои.

---

## 2) Три режима взаимодействия с заказчиком (Human-in-the-loop)

В начале проекта оркестратор обязан определить правила игры:

| Режим | Описание |
|-------|----------|
| **A — Полная автономия** | Команда сама формирует вопросы, сама отвечает, человек только получает итог/дайджест |
| **B — "Есть пожелания, остальное решайте сами"** | Человек задаёт ключевые ограничения, команда закрывает остальное |
| **C — Полный диалог** | Команда формирует список критичных вопросов, человек отвечает/утверждает |

Результат: первый документ проекта — **Project Working Rules** + карта **Quality Gates**.

---

## 3) Контрольные точки как «глобальные quality gates»

Контрольные точки нужны, чтобы:
- Вовремя заметить отклонение
- Остановиться и обсудить
- Сделать откат/перепланирование
- Не «закопаться» в неверной ветке

**Требование**: контрольные точки должны быть формально описаны (условия входа/выхода, критерии качества, кто утверждает).

---

## 4) Итеративное качество и журналирование

**Ключевой принцип**: не нужно бояться несовершенного алгоритма на старте — нужно встроить:
- Проверку качества на каждом шаге
- Циклы критики/улучшений
- Лимиты итераций и правила "что делать, если потолок"
- Логирование всего для улучшения системы

Это делает систему **«самообучающейся организационно»**: слабые карточки выявляются по статистике и переписываются.

---

## 5) Архитектурное усиление из рецензии MESSAGE_FORMAT

Рецензия подтверждает "enterprise-grade" подход:

- ✅ Опора на существующие стандарты (не "изобретение велосипеда")
- ✅ Эталонное разделение ответственности по слоям
- ✅ Зрелая модель COMMAND/RESULT/ERROR (ERROR — отдельный поток)
- ✅ `requirements` связывает оркестрацию с паспортами узлов
- ✅ `context` связывает выполнение с карточкой процесса
- ✅ Идемпотентность + ретраи на стороне оркестратора (не агента)

---

# Часть 2. Подробное изложение по этапам

## Этап 0. Инициация проекта

**Вход**: запрос "сделай X" (книга/ПО/видео — неважно)
**Выход**: создана карточка проекта (Project Card) с базовыми метаданными

---

## Этап 1. Определение правил работы (Project Working Rules)

**Цель**: формализовать взаимодействие «человек ↔️ оркестратор ↔️ команда агентов»

1. Зафиксировать режим автономности: A/B/C
2. Определить список контрольных точек (quality gates) и кто утверждает каждую
3. Зафиксировать принципы коммуникации
4. Зафиксировать политику изменений
5. Зафиксировать протокол "стоп/пауза/эскалация"

**Контрольная точка #1**: утверждение Project Working Rules

---

## Этап 2. Укрупнённая концепция/ТЗ

**Цель**: получить "скелет" проекта

- Что делаем (назначение, ценность, эффект)
- Для кого делаем (аудитория/пользователи)
- Какой результат считаем успехом (KPI/критерии)
- Ограничения (время, бюджет, стиль, запреты, тех.рамки)
- Большая структура результата

**Контрольная точка #2**: утверждение укрупнённой концепции

---

## Этап 3. Аналитика и сбор внешних данных

**Цель**: "не изобретать велосипед" и попасть в реальность

- Анализ аналогов/примеров
- Анализ аудитории и потребностей
- Анализ трендов и форматов
- Анализ готовых инструментов/подходов/шаблонов
- Выводы: что берём, что не берём, почему

**Контрольная точка #3**: утверждение результатов аналитики

---

## Этап 4. Полная техническая документация

**Цель**: убрать "белые пятна" и сделать работу воспроизводимой

**Примеры по типу задачи**:
- **ПО**: архитектура, модули, API/контракты, схемы данных, стандарты, тест-стратегия
- **Книга**: сюжет/структура, персонажи, стиль, объём, ограничения
- **Видео**: сценарий, раскадровка, стиль, длительность, референсы

**Контрольная точка #4**: утверждение полной документации + критериев качества

---

## Этап 5. План реализации (WBS → подзадачи → зависимости)

**Цель**: превратить документацию в исполнимый план

- Декомпозиция на подзадачи
- Для каждой задачи: входы/выходы, Definition of Done, критерии качества, риски
- Определение "глобальных" и "локальных" контрольных точек

**Контрольная точка #5**: утверждение плана

---

## Этап 6. Подбор команды агентов (capability matching)

**Цель**: понять, хватает ли текущих агентов и инструментов

- Сопоставить типы подзадач с "ролью/агентом"
- Если не хватает — сформировать запрос на расширение
- Подбор опирается на `requirements` и `паспорт узла`

**Контрольная точка #6**: утверждение состава команды

---

## Этап 7. Исполнение с качественным циклом

**Цель**: выполнять план с непрерывной оценкой качества

Для каждой подзадачи:
1. Выполнение (агент/агенты)
2. Проверка качества (критик/валидатор/тестировщик)
3. Итерации улучшения: "проверка → критика → предложение → доработка"
4. Условия прохода дальше: условные "98–100%" или иной порог
5. Если после N циклов качество не растёт → эскалация или фиксация "принято с дефектом"

---

## Этап 8. Логи, протоколы, версии, улучшение карточек

**Цель**: сделать систему улучшаемой

- Вести журнал решений
- Вести журнал качества
- По итогам проекта: финальный отчёт и ретроспектива
- Если карточка процесса показала низкую эффективность — создать улучшенную версию

---

## Этап 9. Инфраструктурная опора: Node Registry

Оркестратор как "планировщик" должен знать:
- Кто жив
- Кто что умеет
- Как выбрать исполнителя

Аналогия с Kubernetes: orchestrator как scheduler, node registry как реестр узлов, etcd/Consul как базовая реализация.

---

# Часть 3. Сложности и пути решения

## 1) Формализация "языка" карточек процесса (ISA-слой)

**Вопрос**: насколько карточка должна быть декларативной vs алгоритмической?
**Путь**: простое — по умолчанию, сложное — через расширение

## 2) Валидация карточки до выполнения

Оркестратор должен "прочитать", проверить на ошибки и только потом исполнять.

**Статический анализ**:
- Циклы без выхода
- Неразрешимые зависимости
- Отсутствующие роли/агенты
- Противоречивые критерии качества

## 3) "Кто ретраит, кто отвечает за идемпотентность"

- Агент — "чистый исполнитель"
- Оркестратор управляет ретраями/таймаутами/идемпотентностью
- `idempotency_key` при необходимости

## 4) ERROR как отдельный поток

Чётко определить:
- Какие ошибки retryable
- Какие — "fail fast"
- Какие требуют эскалации
- Какие приводят к смене исполнителя

## 5) Метрики качества: как измерять "98–100%"

**Пути**:
- Доменные рубрики (для кода — тесты/линтер; для книги — критерии стиля)
- Гибрид: автоматические метрики + экспертная оценка
- Хранить историю оценок для улучшения карточек

## 6) Стандартизация Quality Gates как first-class сущности

Gate как объект с полями:
- Что проверяем
- Кто проверяет
- Критерии pass/fail
- Что делать при fail

## 7) Управление версиями и SSOT

Закрепить:
- Где живёт SSOT
- Кто имеет право менять
- Как оформляются версии
- Как связаны все спецификации

## 8) Node Registry: эволюция от MVP к Production

Дорожная карта:
- MVP на in-memory
- Затем etcd/Consul
- Health/heartbeat
- Watch/notifications

---

## Связанные документы

- [ORCHESTRATOR_SPEC_v1.0.md](../../SSOT/ORCHESTRATOR_SPEC_v1.0.md)
- [MESSAGE_FORMAT_v1.1.md](../../SSOT/MESSAGE_FORMAT_v1.1.md)
- [PROCESS_CARD_SPEC_v1.0.md](../../SSOT/PROCESS_CARD_SPEC_v1.0.md)
- [NODE_PASSPORT_SPEC_v1.0.md](../../SSOT/NODE_PASSPORT_SPEC_v1.0.md)
- [NODE_REGISTRY_SPEC_v1.0.md](../../SSOT/NODE_REGISTRY_SPEC_v1.0.md)
