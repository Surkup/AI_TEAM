# Общая архитектура системы AI_TEAM

**Версия**: 1.0
**Дата**: 2025-12-14
**Статус**: Проектирование

---

## 📋 Оглавление

1. [Введение](#введение)
2. [Общая схема системы](#общая-схема-системы)
3. [Компоненты и их роли](#компоненты-и-их-роли)
4. [Принципы взаимодействия](#принципы-взаимодействия)
5. [Технологический стек](#технологический-стек)

---

## Введение

AI_TEAM — это платформа для создания команды AI-агентов, которые работают как единая организация под управлением человека (CEO).

**Ключевая метафора**: Современная компания
- Человек = CEO (ставит цели)
- Orchestrator = Директор (управляет процессами)
- AI-агенты = Сотрудники (выполняют задачи)
- MindBus = Корпоративная сеть (коммуникация)

---

## Общая схема системы

```
┌─────────────────────────────────────────────────────────────────┐
│                         ЧЕЛОВЕК (CEO)                           │
│                    Ставит цели и контролирует                   │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                    ИНТЕРФЕЙС МОНИТОРИНГА                        │
│  ┌─────────────┐  ┌──────────────┐  ┌────────────────────┐     │
│  │   Веб-UI    │  │  Telegram    │  │  Панель статуса    │     │
│  │   (Чат)     │  │    (Боты)    │  │   (Метрики)        │     │
│  └─────────────┘  └──────────────┘  └────────────────────┘     │
└────────────────────────────┬────────────────────────────────────┘
                             │ HTTP/WebSocket
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                        API GATEWAY                              │
│            Аутентификация, Валидация, Маршрутизация             │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                  ORCHESTRATOR (Директор)                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │  Planner     │  │ Coordinator  │  │Quality Control│         │
│  │(Планирование)│  │(Координация) │  │(Контроль)    │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                      MINDBUS (Шина данных)                      │
│  ┌────────────────────────────────────────────────────────┐     │
│  │  • Надёжная доставка сообщений                         │     │
│  │  • Маршрутизация по адресам и типам                    │     │
│  │  • Управление очередями и приоритетами                 │     │
│  │  • Полная трассировка (trace_id)                       │     │
│  │  • Поддержка различных форматов                        │     │
│  └────────────────────────────────────────────────────────┘     │
└──────┬──────────────┬──────────────┬──────────────┬─────────────┘
       │              │              │              │
       ▼              ▼              ▼              ▼
┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐
│ AI-АГЕНТ  │  │ AI-АГЕНТ  │  │ AI-АГЕНТ  │  │ AI-АГЕНТ  │
│  Writer   │  │  Editor   │  │ Developer │  │Researcher │
│           │  │           │  │           │  │           │
│ ┌───────┐ │  │ ┌───────┐ │  │ ┌───────┐ │  │ ┌───────┐ │
│ │Adapter│ │  │ │Adapter│ │  │ │Adapter│ │  │ │Adapter│ │
│ └───┬───┘ │  │ └───┬───┘ │  │ └───┬───┘ │  │ └───┬───┘ │
└─────┼─────┘  └─────┼─────┘  └─────┼─────┘  └─────┼─────┘
      │              │              │              │
      │              │              │              │
      └──────────────┴──────────────┴──────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                   STORAGE LAYER (Хранилище)                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ Operational  │  │ Knowledge    │  │   Artifact   │          │
│  │  Storage     │  │    Base      │  │   Storage    │          │
│  │ (Задачи,     │  │ (Process     │  │ (Файлы,      │          │
│  │  очереди)    │  │  Cards)      │  │  результаты) │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
│                                                                  │
│  ┌──────────────────────────────────────────────────────┐       │
│  │              Audit Log (История операций)            │       │
│  └──────────────────────────────────────────────────────┘       │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│              АДАПТЕРЫ ВНЕШНИХ СЕРВИСОВ                          │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │
│  │PostgreSQL│  │   S3     │  │  OpenAI  │  │   ...    │        │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘        │
└─────────────────────────────────────────────────────────────────┘
```

---

## Компоненты и их роли

### 1. **Интерфейс мониторинга (UI Layer)**

**Назначение**: Точка взаимодействия человека с системой

**Компоненты**:
- **Веб-интерфейс (Главный)**: Чат-подобный "Монитор директора" для постановки задач и получения результатов
- **Telegram/Slack боты**: Критические уведомления и быстрые команды
- **Панель статуса**: Метрики производительности, состояние агентов

**Ключевые функции**:
- Постановка задач естественным языком
- Отображение прогресса выполнения
- Получение результатов
- Управление приоритетами
- Контроль бюджетов

---

### 2. **API Gateway**

**Назначение**: Единая точка входа в систему

**Ключевые функции**:
- Аутентификация и авторизация
- Валидация входящих запросов
- Маршрутизация к нужным сервисам
- Rate limiting
- Логирование запросов

**Технологии** (будут определены при реализации):
- REST API / GraphQL / gRPC
- JWT токены для аутентификации
- OpenAPI спецификация

---

### 3. **Orchestrator (Оркестратор)**

**Назначение**: "Директор компании" — управляет всеми процессами

**Архитектура**:
```
Orchestrator
├── Planner (Планировщик)
│   ├── Анализ задач
│   ├── Выбор Process Card
│   └── Создание плана выполнения
│
├── Coordinator (Координатор)
│   ├── Распределение подзадач
│   ├── Управление зависимостями
│   └── Мониторинг выполнения
│
└── Quality Controller (Контроль качества)
    ├── Оценка результатов
    ├── Запуск циклов улучшения
    └── Сохранение успешных процессов
```

**Основные функции**:

**Planner (Планировщик)**:
- Получает задачу от человека
- Анализирует задачу (что нужно сделать)
- Ищет подходящую Process Card в Knowledge Base
- Если не находит — создаёт новую Process Card
- Формирует план выполнения

**Coordinator (Координатор)**:
- Разбивает процесс на подзадачи
- Определяет какие агенты нужны
- Проверяет доступность агентов (регистр агентов)
- Распределяет задачи с учётом загрузки
- Управляет зависимостями между шагами
- Обрабатывает конфликты ресурсов

**Quality Controller (Контроль качества)**:
- Получает результаты от агентов
- Оценивает качество по критериям из Process Card
- Решает: принять результат или запустить доработку
- Управляет циклами улучшения
- Сохраняет успешные процессы в Knowledge Base

**Состояния задач**:
- `CREATED` — задача создана
- `PLANNED` — план составлен
- `IN_PROGRESS` — выполняется
- `QUALITY_CHECK` — проверка качества
- `REWORK` — на доработке
- `COMPLETED` — успешно завершена
- `FAILED` — завершена с ошибкой

---

### 4. **MindBus (Шина данных)**

**Назначение**: "Нервная система" — единая коммуникационная инфраструктура

**Ключевые принципы**:
1. **Всё через шину** — нет прямых вызовов между компонентами
2. **Единый формат** — канонический Message для всех
3. **Ссылки вместо данных** — большие файлы передаются как ссылки
4. **Полная трассировка** — trace_id связывает все операции
5. **Приоритеты** — критичные сообщения обрабатываются первыми

**Канонический формат Message**:
```yaml
Message:
  id: <UUID>                    # Уникальный идентификатор
  type: COMMAND | RESULT | EVENT # Тип сообщения
  from: <string>                # Отправитель
  to: <string>                  # Получатель
  created_at: <timestamp>       # Время создания
  priority: <int>               # Приоритет (выше = важнее)

  context:
    trace_id: <UUID>            # Сквозная трассировка задачи
    task_id: <UUID>             # ID задачи
    process_id: <UUID>          # ID процесса
    parent_message_id: <UUID>   # Связь с предыдущим сообщением

  payload: <object>             # Полезная нагрузка (зависит от type)
```

**Типы сообщений**:
- **COMMAND** — "Сделай" (поручение выполнить действие)
- **RESULT** — "Вот результат" (ответ на команду)
- **EVENT** — "Произошло" (уведомление о событии)
- **QUERY** — "Дай информацию" (запрос данных)
- **CONTROL** — "Системное управление" (pause, resume, stop)
- **ERROR** — "Ошибка" (детальная диагностика)

**Функции**:
- Маршрутизация сообщений по адресам
- Управление очередями с приоритетами
- Гарантированная доставка (retry механизмы)
- Логирование всех сообщений
- Метрики производительности

---

### 5. **AI-Агенты (AI Agents)**

**Назначение**: "Сотрудники компании" — исполнители задач

**Типы агентов** (примеры):
- **Writer** — создание текстового контента
- **Editor** — проверка и улучшение текстов
- **Developer** — написание кода
- **QA** — тестирование в изолированной среде
- **Researcher** — поиск и анализ информации
- **Designer** — создание визуального контента
- **Analyst** — анализ данных и создание отчётов

**Структура агента**:
```
AI Agent
├── Profile (Профиль)
│   ├── role: "Writer"
│   ├── specialization: "Техническая документация"
│   ├── capabilities: [список компетенций]
│   └── tools: [доступные инструменты]
│
├── Adapter (Адаптер MindBus)
│   ├── Приём COMMAND из MindBus
│   ├── Отправка RESULT в MindBus
│   └── Валидация по SSOT схемам
│
├── Executor (Исполнитель)
│   ├── Обработка задачи
│   ├── Вызов LLM API
│   └── Формирование результата
│
└── Sandbox (Песочница)
    ├── Изоляция выполнения
    ├── Ограничение ресурсов
    └── Контроль безопасности
```

**Регистрация агента**:
1. При запуске агент отправляет EVENT `agent_registered`
2. Payload содержит профиль агента (роль, компетенции)
3. Orchestrator записывает агента в реестр
4. Теперь Orchestrator знает, какие задачи можно поручать этому агенту

**Жизненный цикл агента**:
- `STARTING` → `AVAILABLE` → `BUSY` → `AVAILABLE` → ...
- Возможные состояния: `STARTING`, `AVAILABLE`, `BUSY`, `OVERLOADED`, `UNAVAILABLE`, `ERROR`

---

### 6. **Storage Layer (Слой хранения)**

**Назначение**: "Корпоративная библиотека и архив"

**Логические уровни**:

**Operational Storage** — оперативные данные:
- Текущие задачи (Task)
- Очереди сообщений
- Состояния агентов
- Контекст выполняемых процессов

**Knowledge Base** — база знаний:
- Process Cards (карточки процессов)
- Успешные практики
- История решений
- Шаблоны и примеры

**Artifact Storage** — результаты работы:
- Текстовые файлы
- Изображения и видео
- Код и конфигурации
- Отчёты и аналитика

**Audit Log** — история операций:
- Все сообщения MindBus
- Логи агентов
- Решения Orchestrator
- Действия человека

**Принцип работы**:
- Агенты/Orchestrator отправляют COMMAND `store_artifact` в MindBus
- Storage Adapter принимает команду
- Сохраняет данные в соответствующее хранилище
- Возвращает RESULT с `artifact_id` или ссылкой
- Большие данные передаются как ссылки, не inline

---

### 7. **Process Cards (Карточки процессов)**

**Назначение**: "Должностные инструкции" — формальное описание бизнес-процессов

**Структура Process Card**:
```yaml
ProcessCard:
  id: <UUID>
  name: "Создание технической статьи"
  version: "1.0.0"

  intent: "Создать качественную техническую статью по заданной теме"

  steps:
    - id: "research"
      agent_role: "Researcher"
      action: "Собрать информацию по теме"
      input: { topic: "${task.topic}" }
      output: "research_data"

    - id: "write_draft"
      agent_role: "Writer"
      action: "Написать первый вариант статьи"
      input: { research: "${steps.research.output}" }
      output: "draft_text"
      depends_on: ["research"]

    - id: "review"
      agent_role: "Editor"
      action: "Проверить качество текста"
      input: { text: "${steps.write_draft.output}" }
      output: "review_result"
      depends_on: ["write_draft"]

    - id: "improve"
      agent_role: "Writer"
      action: "Улучшить текст по замечаниям"
      input:
        text: "${steps.write_draft.output}"
        feedback: "${steps.review.output}"
      output: "final_text"
      depends_on: ["review"]
      condition: "review_result.quality < 8"

  quality_criteria:
    - "Текст без ошибок"
    - "Соответствие теме"
    - "Читабельность > 7/10"
    - "Наличие примеров"

  budget:
    max_cost: 5.00  # USD
    max_time: 3600  # секунд
    max_iterations: 3
```

**Элементы Process Card**:
- **Intent** — зачем выполняется задача
- **Steps** — последовательность шагов
- **Dependencies** — зависимости между шагами
- **Conditions** — условия ветвления
- **Quality Criteria** — критерии успеха
- **Budget** — ограничения на ресурсы

**Хранение**:
- Process Cards хранятся в Knowledge Base
- Версионируются (v1.0.0, v1.1.0, v2.0.0)
- Имеют метрики эффективности
- Переиспользуются для похожих задач

---

## Принципы взаимодействия

### 1. **Асинхронная коммуникация**

Все компоненты общаются **асинхронно** через MindBus:
- Отправитель не ждёт ответа (fire-and-forget)
- Ответы приходят как отдельные сообщения
- Связь через `trace_id` и `parent_message_id`

**Преимущества**:
- Компоненты независимы
- Высокая отказоустойчивость
- Возможность масштабирования

### 2. **Event-Driven Architecture (Событийная архитектура)**

Система реагирует на события:
- `task_created` → Orchestrator начинает планирование
- `agent_registered` → Orchestrator обновляет реестр
- `task_completed` → Уведомление человеку
- `quality_check_failed` → Запуск цикла улучшения

### 3. **Publish-Subscribe паттерн**

Компоненты подписываются на интересующие их типы сообщений:
- Orchestrator подписан на: `task_created`, `result_received`
- Monitor подписан на: **все сообщения**
- Agent подписан на: `COMMAND` где `to=agent_id`

### 4. **Идемпотентность**

Все операции **идемпотентны** — повторное выполнение даёт тот же результат:
- Сообщения могут доставляться дважды (retry)
- Компоненты проверяют "уже обработал ли я это?"
- Защита от дублирования операций

### 5. **Trace ID — сквозная трассировка**

Каждая задача получает уникальный `trace_id`:
- Все сообщения одной задачи имеют одинаковый `trace_id`
- Можно отследить весь путь задачи через систему
- Упрощает отладку и аудит

---

## Технологический стек

**ВАЖНО**: Конкретные технологии будут выбраны на этапе реализации.

**Возможные варианты**:

### Backend
- **Язык**: Python, Node.js, или Go
- **MindBus**: RabbitMQ, Kafka, Redis Pub/Sub, или NATS
- **API Gateway**: FastAPI, Express, или Kong

### Storage
- **Operational DB**: PostgreSQL, MongoDB
- **Cache**: Redis, Memcached
- **File Storage**: S3, MinIO, локальная FS
- **Vector DB** (для Knowledge Base): Pinecone, Weaviate, Qdrant

### AI Провайдеры
- OpenAI API (GPT-4, GPT-3.5)
- Anthropic API (Claude)
- Локальные модели (Llama, Mistral)

### Frontend
- **Web UI**: React, Vue, Svelte
- **Real-time**: WebSocket, Server-Sent Events
- **Telegram Bot**: python-telegram-bot, telegraf.js

### Infrastructure
- **Контейнеризация**: Docker, Docker Compose
- **Оркестрация** (для production): Kubernetes
- **Мониторинг**: Prometheus, Grafana
- **Логирование**: ELK Stack (Elasticsearch, Logstash, Kibana)

---

## Следующие шаги

1. ✅ Общая схема системы (этот документ)
2. ⏭️ [Путь пользователя (User Journey)](02_USER_JOURNEY.md)
3. ⏭️ [Потоки данных (Data Flow)](03_DATA_FLOW.md)
4. ⏭️ [Жизненный цикл сущностей](04_ENTITY_LIFECYCLE.md)

---

**Статус**: ✅ Готово
**Последнее обновление**: 2025-12-14
