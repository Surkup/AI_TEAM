# Принцип "Готовые решения первичны"

**Статус**: ✅ Утверждённый принцип
**Версия**: 1.0
**Дата**: 2025-12-15

---

## TL;DR (Executive Summary)

**ДО принятия любого архитектурного решения:**

1. Поиск существующих стандартов (RFC, ISO, CNCF, W3C)
2. Анализ готовых реализаций (Open Source, Cloud providers)
3. Сравнительная таблица (что покрывает / не покрывает)
4. Решение: готовое ИЛИ custom (с обоснованием)

**Разработка с нуля = крайняя мера** (требует ADR документа).

---

## Чеклист принятия решения

### ☑️ Перед проектированием компонента

- [ ] Сформулированы чёткие требования (must have / nice to have)
- [ ] Найдены минимум 3 существующих решения
- [ ] Проверено: есть ли RFC/ISO/CNCF стандарт для этой задачи?
- [ ] Проанализированы готовые реализации (Open Source + Commercial)
- [ ] Создана сравнительная таблица "Требование vs Решение"
- [ ] Оценено: покрывает ли лучшее решение ≥80% требований?

### ☑️ Если выбрано готовое решение

- [ ] Есть полная техническая документация (не просто "Getting Started")
- [ ] Есть доступ к исходному коду (GitHub/GitLab)
- [ ] Есть готовые библиотеки для Python (обязательно) + Go (желательно)
- [ ] Решение используется в production >3 лет (примеры компаний)
- [ ] Последний commit/release не старше 6 месяцев
- [ ] Community: >1000 GitHub stars ИЛИ коммерческая поддержка
- [ ] License совместима с проектом (Apache 2.0, MIT, BSD preferred)
- [ ] Создан документ решения в соответствующей секции (SSOT spec или docs/technical/stack/)

### ☑️ Если выбрана разработка с нуля

- [ ] Задокументированы ВСЕ найденные готовые решения
- [ ] Для КАЖДОГО решения объяснено: почему не подходит
- [ ] Оценён объём работы: человеко-недели разработки
- [ ] Оценена долгосрочная поддержка (maintenance cost)
- [ ] Получено одобрение команды/архитектора
- [ ] Создан ADR: `docs/architecture/decisions/ADR-XXX-custom-COMPONENT.md`
- [ ] В ADR описаны риски и план миграции (если найдём готовое решение позже)

---

## Источники поиска стандартов

### 1. Сетевые протоколы и интеграция

- **IETF RFC**: https://www.rfc-editor.org/
  - Примеры: HTTP (RFC 2616), TCP/IP (RFC 793, 791), AMQP (RFC 9124), MQTT, WebSocket (RFC 6455)

- **OASIS**: https://www.oasis-open.org/standards/
  - Примеры: AMQP 1.0, MQTT 3.1.1/5.0, SAML 2.0

### 2. Cloud Native и распределённые системы

- **CNCF Projects**: https://www.cncf.io/projects/
  - Примеры: Kubernetes, Prometheus, gRPC, OpenTelemetry, CloudEvents, NATS, Envoy

- **Apache Software Foundation**: https://projects.apache.org/
  - Примеры: Kafka, Pulsar, Airflow, Camel, ActiveMQ

### 3. Web стандарты

- **W3C**: https://www.w3.org/TR/
  - Примеры: Trace Context (W3C Recommendation), WebSocket, Server-Sent Events

### 4. Общие IT стандарты

- **ISO/IEC**: https://www.iso.org/
  - Примеры: ISO 19464 (AMQP), ISO 27001 (Security), ISO 9075 (SQL)

---

## Примеры решений (Case Studies)

### ✅ Case 1: MindBus Protocol

**Задача**: Разработать протокол коммуникации между компонентами AI_TEAM.

**Требования**:
- Надёжная доставка сообщений
- Приоритеты (критичные обгоняют обычные)
- Маршрутизация по ролям
- Трассировка end-to-end
- Pub/Sub + Request/Reply

**Процесс**:

1. **Поиск стандартов**: AMQP (OASIS, ISO 19464), MQTT (OASIS), gRPC (CNCF), NATS
2. **Анализ решений**: RabbitMQ, Apache Pulsar, NATS JetStream, Apache Kafka
3. **Сравнение**:

| Требование | RabbitMQ (AMQP) | NATS | Kafka | Custom |
|------------|-----------------|------|-------|--------|
| Надёжность | ✅ Persistence | ✅ JetStream | ✅ | ⚠️ Нужно писать |
| Приоритеты | ✅ Priority Queues | ✅ | ❌ | ⚠️ Нужно писать |
| Routing | ✅ Topic Exchange | ✅ Subjects | ⚠️ Topics | ⚠️ Нужно писать |
| Request/Reply | ✅ RPC | ✅ | ❌ | ⚠️ Нужно писать |
| Трассировка | ⚠️ (нужен W3C) | ⚠️ (нужен W3C) | ⚠️ | ⚠️ Нужно писать |

4. **Решение**: RabbitMQ (AMQP) + CloudEvents (формат) + W3C Trace Context
5. **Покрытие**: 95% требований
6. **Документ**: `docs/SSOT/MINDBUS_PROTOCOL.md` (создан)

**Результат**:
- Время интеграции: 1-2 недели (vs 7-10 недель custom разработки)
- Production-ready: используется 15+ лет (банки, телеком)
- Поддержка: VMware + огромное сообщество

---

### ✅ Case 2: Storage для артефактов (будущий)

**Задача**: Система хранения файлов, результатов работы агентов.

**Требования**:
- Хранение файлов любого размера
- Быстрый доступ по ID
- Версионирование
- Масштабируемость

**Процесс поиска** (когда будет актуально):

1. **Поиск стандартов**: S3 API (де-факто стандарт), WebDAV (RFC 4918)
2. **Анализ решений**: MinIO, SeaweedFS, Ceph, OpenStack Swift
3. **Сравнение**:

| Требование | MinIO | SeaweedFS | Ceph | Custom |
|------------|-------|-----------|------|--------|
| S3 API | ✅ | ⚠️ | ✅ | ❌ |
| Простота | ✅ | ✅ | ❌ | ⚠️ |
| Масштаб | ✅ | ✅ | ✅ | ⚠️ |
| Версионирование | ✅ | ❌ | ✅ | ⚠️ |

4. **Вероятное решение**: MinIO (S3-совместимое, легковесное)

---

## Anti-patterns (Чего НЕ делать)

### ❌ Anti-pattern 1: "Inspired by X"

**НЕПРАВИЛЬНО**:
```
"Мы разработаем свой протокол, вдохновлённый IPv4"
→ Пишем 20-byte header, парсер, валидатор, тесты
→ 7-10 недель разработки
→ Поддержка вечно на нас
```

**ПРАВИЛЬНО**:
```
"Мы используем AMQP (стандарт, вдохновлённый опытом банков)"
→ Устанавливаем RabbitMQ
→ Пишем SDK обёртку (~300 строк)
→ 1-2 недели интеграции
```

**Почему неправильно**: "Вдохновлённый X" обычно означает "взял идеи, но написал с нуля". Это НЕ переиспользование, это custom разработка.

---

### ❌ Anti-pattern 2: "Почти подходит, но..."

**НЕПРАВИЛЬНО**:
```
"RabbitMQ почти подходит, но нет встроенной сериализации Protobuf,
поэтому напишем свой протокол"
```

**ПРАВИЛЬНО**:
```
"RabbitMQ покрывает 90% требований.
Для сериализации используем CloudEvents (JSON) или Protobuf отдельно.
Это OK — остаёмся на готовом решении."
```

**Почему неправильно**: Отказ от готового решения из-за одной недостающей фичи (10% требований) приводит к написанию 100% кода с нуля. Лучше добавить 10% обёртки.

---

### ❌ Anti-pattern 3: "У нас особый случай"

**НЕПРАВИЛЬНО**:
```
"Наша задача уникальна, готовые решения не подходят"
```

**ПРАВИЛЬНО**:
```
"Наша задача имеет специфику X.
Проанализировали решения A, B, C.
Решение B покрывает 80% + мы адаптируем 20% через обёртку.
Используем B."
```

**Почему неправильно**: В 99% случаев "уникальная задача" — это комбинация известных паттернов. Настоящая уникальность встречается крайне редко.

---

### ❌ Anti-pattern 4: "Готовое решение слишком тяжёлое"

**НЕПРАВИЛЬНО**:
```
"RabbitMQ слишком сложный для нашей задачи,
напишем простую очередь на Redis"
```

**ПРАВИЛЬНО**:
```
"RabbitMQ — production-grade решение. Да, сложнее чем нужно,
но это ХОРОШО — есть куда расти. Используем базовые фичи сейчас,
продвинутые позже."
```

**Почему неправильно**: "Слишком мощное" решение обычно означает "много фич из коробки". Это плюс, не минус. Простое самописное решение быстро перерастёт в сложное, но без документации и поддержки.

---

### ❌ Anti-pattern 5: "Напишем быстрее чем разберёмся"

**НЕПРАВИЛЬНО**:
```
"На изучение RabbitMQ уйдёт неделя,
за это время мы уже напишем свою очередь"
```

**ПРАВИЛЬНО**:
```
"На изучение RabbitMQ уйдёт неделя.
На написание своей очереди — 2-3 недели + вечная поддержка.
Потратим неделю на изучение RabbitMQ."
```

**Почему неправильно**: Учёт только первоначальной разработки, игнорирование долгосрочной поддержки, багфиксов, документации, масштабирования.

---

## Исключения: Когда МОЖНО писать с нуля

### ✅ Исключение 1: Security vulnerabilities

**Пример**:
```
Готовое решение X имеет известную уязвимость CVE-2024-XXXX,
патча нет, альтернатив нет.
→ Пишем свою реализацию с фокусом на security.
```

**Требование**: Документировать CVE, почему патча нет, когда планируем вернуться к готовому решению.

---

### ✅ Исключение 2: Licensing conflicts

**Пример**:
```
Готовое решение под GPL, наш проект коммерческий.
Все альтернативы тоже GPL или платные.
→ Пишем свою реализацию под MIT.
```

**Требование**: Документировать все рассмотренные альтернативы и их лицензии.

---

### ✅ Исключение 3: Performance critical

**Пример**:
```
Профилирование показало: готовое решение X в 10 раз медленнее требуемого.
Оптимизация невозможна (архитектурное ограничение).
→ Пишем custom high-performance реализацию.
```

**Требование**: Приложить результаты профилирования, доказать что 10x gap критичен.

---

### ✅ Исключение 4: Интеграция дороже разработки

**Пример**:
```
Готовое решение требует переписать 80% существующего кода.
Оценка: 6 недель интеграции vs 3 недели custom разработки.
→ Пишем custom.
```

**Требование**: Детальная оценка трудозатрат на оба варианта.

---

## Финальное правило

> **"Если существует стандарт (RFC/ISO/CNCF) и есть production-grade реализация —
> мы ОБЯЗАНЫ использовать её. Custom разработка = exception, не правило."**

---

## Архитектурные аналогии в AI_TEAM

При проектировании компонентов AI_TEAM мы опираемся на архитектурные аналогии из зрелых систем. Это помогает понять решения через призму проверенных паттернов:

### Node Passport → Device Descriptors

**Аналоги**:
- **PCI / USB device descriptors** — устройства сами описывают свои возможности
- **Сетевая регистрация (Ethernet, Wi-Fi)** — узлы регистрируются в сети автоматически
- **Kubernetes Node Spec** — узлы кластера декларируют ресурсы и capabilities

**Принцип**: Каждый узел AI_TEAM сам себя описывает через NODE PASSPORT, система автоматически обнаруживает возможности.

---

### Node Registry → Service Discovery

**Аналоги**:
- **Kubernetes Node Registry** — централизованный реестр узлов кластера
- **Consul Service Discovery** — автоматическое обнаружение сервисов
- **PnP (Plug and Play) в ОС** — автоматическое обнаружение устройств

**Принцип**: Registry хранит паспорта всех узлов, Оркестратор находит подходящие через capability matching.

---

### Task Scheduling → OS/Cloud Scheduler

**Аналоги**:
- **Kubernetes Scheduler** — назначение Pod'ов на Nodes по ресурсам и constraints
- **OS Process Scheduler** — распределение процессов по CPU cores
- **Nomad Job Allocation** — распределение задач по узлам кластера

**Принцип**: Оркестратор AI_TEAM использует capability-based scheduling — находит узел с нужными возможностями, проверяет constraints, назначает задачу.

---

### MindBus → Data Bus

**Аналоги**:
- **Компьютерная шина данных (PCI, USB)** — передача данных между компонентами
- **Message Bus (RabbitMQ, Kafka)** — асинхронная передача сообщений
- **Enterprise Service Bus (ESB)** — интеграция корпоративных систем

**Принцип**: MindBus соединяет все узлы AI_TEAM, обеспечивая надёжную доставку сообщений с приоритетами и трассировкой.

---

### Process Cards → Workflow Definitions

**Аналоги**:
- **Kubernetes Job/CronJob specs** — декларативное описание задач
- **Argo Workflows / Temporal** — workflow orchestration
- **GitHub Actions / GitLab CI YAML** — декларативные pipeline definitions

**Принцип**: Process Cards описывают ЧТО нужно сделать (требования), НЕ указывая КАК и на каких конкретных узлах.

---

**Зачем эти аналогии?**

1. **Упрощают понимание** — новые разработчики быстрее понимают архитектуру через знакомые паттерны
2. **Снижают риски** — используем проверенные решения вместо экспериментов
3. **Обеспечивают масштабируемость** — паттерны Kubernetes работают с миллионами узлов
4. **Упрощают интеграцию** — совместимость с существующей инфраструктурой

**Правило**: Если компонент AI_TEAM начинает усложняться — возвращаемся к архитектурной аналогии и проверяем, не отклонились ли мы от проверенного паттерна.

---

## Связанные документы

- [CLAUDE.md](../../CLAUDE.md) — правила для AI-ассистента (секция 0)
- [PROJECT_OVERVIEW.md](../../PROJECT_OVERVIEW.md) — концепция проекта (секция "Опора на проверенные архитектуры")
- [README.md](../../README.md) — краткое описание принципов

---

**Последнее обновление**: 2025-12-15
**Автор**: AI_TEAM Core Team
